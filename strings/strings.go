package strings

import (
	"fmt"
	"math/rand"
	"regexp"
	base "strings"
	"time"
)

// constants & variables ******************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************

// public functions ***********************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************

// Format
// ****************************************************************************************************************************************
func Format(format string, args ...interface{}) string {
	return fmt.Sprintf(format, args...)
}

// Find
// ****************************************************************************************************************************************
func Find(str, pattern string) string {
	return regexp.MustCompile(pattern).FindString(str)
}

// HasPrefix
// ****************************************************************************************************************************************
func HasPrefix(str, pre string) bool {
	return base.HasPrefix(str, pre)
}

// HasSuffix
// ****************************************************************************************************************************************
func HasSuffix(str, suf string) bool {
	return base.HasSuffix(str, suf)
}

// Join
// ****************************************************************************************************************************************
func Join(strs []string, sep string) string {
	return base.Join(strs, sep)
}

// OmitEmpty
// ****************************************************************************************************************************************
func OmitEmpty(strs []string) []string {
	return omit(strs, func(s string) bool {
		return s == ""
	})
}

// Omit
// ****************************************************************************************************************************************
func Omit(strs []string, pattern string) []string {
	r := regexp.MustCompile(pattern)

	return omit(strs, func(s string) bool {
		return r.MatchString(s)
	})
}

// Parse
// ****************************************************************************************************************************************
func Parse(str, format string, args ...interface{}) (err error) {
	_, err = fmt.Sscanf(str, format, args...)

	return
}

// Random
// ****************************************************************************************************************************************
func Random(size int) string {
	rs := make([]rune, size)
	rd := rand.New(rand.NewSource(time.Now().UnixNano()))
	for i := 0; i < size; {
		if r := (rd.Intn(74) + 48); (r >= 48 && r <= 57) || (r >= 65 && r <= 90) || (r >= 97 && r <= 122) {
			rs[i] = rune(r)
			i++
		}
	}

	return string(rs)
}

// Reverse
// ****************************************************************************************************************************************
func Reverse(str string) string {
	r := []rune(str)
	for i, j := 0, len(r)-1; i < len(r)/2; i, j = i+1, j-1 {
		r[i], r[j] = r[j], r[i]
	}

	return string(r)
}

// ToLower
// ****************************************************************************************************************************************
func ToLower(str string) string {
	return base.ToLower(str)
}

// ToUpper
// ****************************************************************************************************************************************
func ToUpper(str string) string {
	return base.ToUpper(str)
}

// type defineds **************************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************

// private functions **********************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************

// omit ***********************************************************************************************************************************
func omit(strs []string, fn func(string) bool) (rtn []string) {
	rtn = make([]string, 0, len(strs))
	for _, v := range strs {
		if !fn(v) {
			rtn = append(rtn, v)
		}
	}

	return
}
