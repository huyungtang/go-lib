package http

import (
	"encoding/json"
	"io"
	base "net/http"
	"net/url"
	"strings"
)

// constants & variables ******************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************

// public functions ***********************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************

// type defineds **************************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************

// context ********************************************************************************************************************************
type context struct {
	Option
	*base.Response
	body []byte
	err  error
}

// Context
// ****************************************************************************************************************************************
type Context interface {
	Body() []byte
	Err() error
	Next()
	ParseJson(interface{}) error
	Status() string
	StatusCode() int
	String() string
}

// Body
// ****************************************************************************************************************************************
func (o *context) Body() []byte {
	return o.body
}

// Err
// ****************************************************************************************************************************************
func (o *context) Err() (err error) {
	return o.err
}

// Next
// ****************************************************************************************************************************************
func (o *context) Next() {
	o.Handler++
	if o.Handler >= len(o.Handlers) || o.Handlers[o.Handler] == nil {
		return
	}

	o.Handlers[o.Handler](o)
}

// Parse
// ****************************************************************************************************************************************
func (o *context) ParseJson(dto interface{}) (err error) {
	return json.Unmarshal(o.body, dto)
}

// Status
// ****************************************************************************************************************************************
func (o *context) Status() (s string) {
	if o.Response != nil {
		s = o.Response.Status
	}

	return
}

// StatusCode
// ****************************************************************************************************************************************
func (o *context) StatusCode() (c int) {
	if o.Response != nil {
		c = o.Response.StatusCode
	}

	return
}

// String
// ****************************************************************************************************************************************
func (o *context) String() string {
	return string(o.body)
}

// requestCore ****************************************************************************************************************************
func (o *context) requestCore(method, path string, opts []Options) {
	handler := HandlerOption(func(c Context) {
		if ctx, isOK := c.(*context); isOK {
			vals := &url.Values{}
			for _, pars := range ctx.Params {
				vals.Add(pars[0], pars[1])
			}

			var body io.Reader
			switch method {
			case base.MethodGet:
				ctx.Host.RawQuery = vals.Encode()
			case base.MethodPost:
				body = strings.NewReader(vals.Encode())
			}

			var req *base.Request
			ctx.Host.Path = path
			if req, ctx.err = base.NewRequest(method, ctx.Host.String(), body); ctx.err != nil {
				return
			}

			for _, hdrs := range ctx.Headers {
				req.Header.Add(hdrs[0], hdrs[1])
			}

			for _, ckes := range ctx.Ckies {
				req.AddCookie(ckes)
			}

			var resp *base.Response
			c := new(base.Client)
			if resp, ctx.err = c.Do(req); ctx.err != nil {
				return
			}
			defer resp.Body.Close()

			if resp.Body != nil {
				ctx.body, ctx.err = io.ReadAll(resp.Body)
			}
			ctx.Response = resp
			o.Ckies = resp.Cookies()
		}

		c.Next()
	})

	o.ApplyOptions(opts, handler)
	o.Handler = -1
	o.Next()
}

// ContextHandler
// ****************************************************************************************************************************************
type ContextHandler func(Context)

// private functions **********************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************
