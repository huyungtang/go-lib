package watcher

import (
	"errors"

	"github.com/fsnotify/fsnotify"
	"github.com/huyungtang/go-lib/file"
)

// constants & variables ******************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************

// public functions ***********************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************

// Init
// ****************************************************************************************************************************************
func Init(opts ...file.Options) (event Watcher, err error) {
	var fw *fsnotify.Watcher
	if fw, err = fsnotify.NewWatcher(); err != nil {
		return
	}

	cfg := file.ApplyOptions(opts)
	if len(cfg.Path) == 0 {
		return nil, errors.New("no path to watch")
	}

	return &watcher{
		Watcher: fw,
		Option:  cfg,
	}, nil
}

// type defineds **************************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************

// watcher ********************************************************************************************************************************
type watcher struct {
	*fsnotify.Watcher
	*file.Option
}

// Watcher
// ****************************************************************************************************************************************
type Watcher interface {
	Watch() *watcherEvent
	Close() error
}

// Event
// ****************************************************************************************************************************************
func (o *watcher) Watch() (event *watcherEvent) {
	event = &watcherEvent{
		Watch: make(chan *watcherContext),
		Error: make(chan error),
	}

	go func(evt *watcherEvent) {
		for {
			select {
			case e, isOK := <-o.Watcher.Events:
				if isOK &&
					(e.Op&fsnotify.Op(o.Option.Op) == e.Op) &&
					(o.Option.Filter == nil || o.Option.Filter.MatchString(e.Name)) {
					evt.Watch <- &watcherContext{Event: file.FileOp(e.Op), Name: e.Name}
				}
			case e := <-o.Watcher.Errors:
				evt.Error <- e
			}
		}
	}(event)

	for _, path := range o.Option.Path {
		o.Watcher.Add(path)
	}

	return
}

// Close
// ****************************************************************************************************************************************
func (o *watcher) Close() (err error) {
	if o.Watcher != nil {
		err = o.Watcher.Close()
	}

	return
}

// watcherEvent ***************************************************************************************************************************
type watcherEvent struct {
	Watch chan *watcherContext
	Error chan error
}

// watcherContext *************************************************************************************************************************
type watcherContext struct {
	Event file.FileOp
	Name  string
}

// private functions **********************************************************************************************************************
// ****************************************************************************************************************************************
// ****************************************************************************************************************************************
